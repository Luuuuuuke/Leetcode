public class ConstructBinaryTree2 {	public class TreeNode {		      public int val;		      public TreeNode left, right;		      public TreeNode(int val) {		          this.val = val;		          this.left = this.right = null;		      }		  }	/**     *@param inorder : A list of integers that inorder traversal of a tree     *@param postorder : A list of integers that postorder traversal of a tree     *@return : Root of a tree     */    public TreeNode buildTree(int[] inorder, int[] postorder) {        if(inorder == null || postorder == null || inorder.length != postorder.length){            return null;        }        return buildTree(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);    }            public TreeNode buildTree(int[] inorder, int[] postorder, int instart, int inend,                                 int poststart, int postend){        if(instart > inend) return null;        TreeNode root = new TreeNode(postorder[postend]);        // find the root in in[]        int i = inend;        for(; i >= instart; i--){            if(inorder[i] == postorder[postend]){                break;            }        }        TreeNode left = buildTree(inorder, postorder, instart, i - 1, poststart, poststart + i - instart - 1);        TreeNode right = buildTree(inorder, postorder, i + 1, inend, poststart + i - instart, postend - 1);        root.left = left;        root.right = right;        return root;    }}