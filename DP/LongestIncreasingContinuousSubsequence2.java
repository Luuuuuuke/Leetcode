public class LongestIncreasingContinuousSubsequence2 {	/**	 * @param A an integer matrix	 * @return an integer	 */	 // Memorized search	 public int longestIncreasingContinuousSubsequenceII(int[][] A) {	     if(A == null || A.length == 0 || A[0].length == 0) return 0;	    int row = A.length, col = A[0].length;	    // dp[i][j] means, start from i ,j, the longest subsequence	    int[][] dp = new int[row][col];	    int maxLen = 0;	    for(int i = 0; i < row; i++){	        for(int j = 0; j < col; j++){	            if(dp[i][j] == 0){	                maxLen = Math.max(maxLen, dfs(A, dp, i, j));	            }	        }	    }	    return maxLen;	 }	 	 public int dfs(int[][] A, int[][] dp, int row, int col){	     if(dp[row][col] != 0) return dp[row][col];	     int up = 0, right = 0, bot = 0, left = 0;	     if(row - 1 >= 0 && A[row-1][col] > A[row][col]){	         up = dfs(A,dp,row-1,col);	     }	     if(col + 1 < A[0].length && A[row][col+1] > A[row][col]){	         right = dfs(A,dp,row,col+1);	     }	     if(row + 1 < A.length && A[row+1][col] > A[row][col]){	         bot = dfs(A,dp,row+1,col);	     }	     if(col - 1 >= 0 && A[row][col-1] > A[row][col]){	         left = dfs(A,dp,row,col-1);	     }	     dp[row][col] = Math.max(Math.max(up, left), Math.max(bot,right)) + 1;	     return dp[row][col];	 }}