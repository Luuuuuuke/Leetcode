public class EncodeStringWithShortestLength {	public String encode(String s) {        if(s == null || s.length() == 0){            return "";        }        // dp[i][j] denotes the string from i,j in shortest encoded format, we want dp[0][s.length() - 1]        // j - i >= 4 so that encoded will be shorter        // if(dp[i][k] + dp[k][j]) is shorter,update dp[i][j];         // or dp[i][j] can be constructed by its own repeated pattern if exists        String[][] dp = new String[s.length()][s.length()];        // from gap = 0, 1 ... s.length() - 1        for(int gap = 0; gap < s.length(); gap++){            for(int i = 0; i < s.length() - gap; i++){                int j = i + gap;                dp[i][j] = s.substring(i, j + 1);                // too short to encode                if(j - i < 4){                    continue;                }                // find a k from i to j, so that (dp[i][k] + dp[k+1][j]) is shorter,update dp[i][j] with it;                 for(int k = i; k < j; k++){                    String tmp = dp[i][k] + dp[k+1][j];                    if(tmp.length() < dp[i][j].length()){                        dp[i][j] = tmp;                    }                }                                // find its own pattern if exist to encode it shorter                String subStr = s.substring(i, j + 1);                for(int k = 0; k < subStr.length() / 2; k++){                    String pattern = subStr.substring(0, k+1);                    // see if the whole string can be replaced by the pattern                    if(subStr.length() % pattern.length() == 0 && subStr.replaceAll(pattern, "").length() == 0){                        String encoded = subStr.length() / pattern.length() + "[" + dp[i][i + k] + "]";                        if(encoded.length() < dp[i][j].length()){                            dp[i][j] = encoded;                        }                    }                }            }        }        return dp[0][s.length() - 1];    }}