import java.util.*;public class SkylineProblem {	private class Node{        int x, height;        boolean enter; // true : is entering node;  false: is leaving node        Node(int x, int height, boolean enter){            this.x = x;            this.height = height;            this.enter = enter;        }    }        public class NodeComparator implements Comparator<Node>{        public int compare(Node n1, Node n2){            if(n1.x == n2.x){                 if(n1.enter && n2.enter){                    return n2.height - n1.height;                 }                 else if(!n1.enter && !n2.enter){                    return n1.height - n2.height;                 }                 else if(n1.enter){                     return -1;                 } else {                     return 1;                 }            }            else {               return n1.x - n2.x;            }                    }    }        public class HeightComparator implements Comparator<Integer>{        public int compare(Integer num1, Integer num2){            return num2 - num1;        }    }        public List<int[]> getSkyline(int[][] buildings) {                List<int[]> res = new ArrayList<int[]>();        if(buildings == null || buildings.length == 0 || buildings[0].length == 0){            return res;        }        ArrayList<Node> nodes = new ArrayList<Node>();        for(int i = 0; i < buildings.length; i++){            nodes.add(new Node(buildings[i][0], buildings[i][2], true));            nodes.add(new Node(buildings[i][1], buildings[i][2], false));        }                Collections.sort(nodes, new NodeComparator());        // only when the maximum in max heap change, the node will be added as update dot        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(1, new HeightComparator());        ArrayList<int[]> dots = new ArrayList<int[]>();        dots.add(new int[]{nodes.get(0).x, nodes.get(0).height});        pq.add(nodes.get(0).height);        for(int i = 1; i < nodes.size(); i++){            int x = nodes.get(i).x;            int height = nodes.get(i).height;            boolean enter = nodes.get(i).enter;            if(enter){                int cur_Max = pq.isEmpty() ? 0 : pq.peek();                if(height > cur_Max){                    dots.add(new int[]{x, height});                }                pq.offer(height);            } else {                // O(n) to remove a certain node                pq.remove(height);                if(pq.isEmpty()){                    dots.add(new int[]{x, 0});                }                else if(pq.peek() < height){                    dots.add(new int[]{x, pq.peek()});                }            }        }                return dots;    }}