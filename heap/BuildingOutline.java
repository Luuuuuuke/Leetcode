import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;public class BuildingOutline {	private class Point{        int x;        int h;        int flag;        public Point(int x, int h, int flag){            this.x = x;            this.h = h;            this.flag = flag;        }                public boolean equals(Object o){            if(!(o instanceof Point)) return false;            Point another = (Point)o;            if(this.h == another.h) return true;            else return false;        }    }        public class HeightComparator implements Comparator<Integer>{        public int compare(Integer a, Integer b){            return b - a;        }    }        public class PosComparator implements Comparator<Point>{        public int compare(Point a, Point b){            if(a.x != b.x) return a.x - b.x;            if(a.flag == 0 && b.flag == 0) return b.h - a.h;            if(a.flag == 1 && b.flag == 1) return a.h - b.h;            return a.flag == 0 ? -1 : 1;        }    }        public ArrayList<ArrayList<Integer>> fixOutLine(ArrayList<ArrayList<Integer>> res){        ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();        int pre = res.get(0).get(0), height = res.get(0).get(1);        for(int i = 1; i < res.size(); i++){            int cur = res.get(i).get(0);            if(height > 0)            ans.add(new ArrayList<Integer>(Arrays.asList(pre, cur, height)));            height = res.get(i).get(1);            pre = cur;        }        return ans;    }        /**     * @param buildings: A list of lists of integers     * @return: Find the outline of those buildings     */    public ArrayList<ArrayList<Integer>> buildingOutline(int[][] buildings) {        if(buildings == null || buildings.length == 0) return new ArrayList<ArrayList<Integer>>();        ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();        ArrayList<Point> p = new ArrayList<Point>();        for(int i = 0; i < buildings.length; i++){            p.add(new Point(buildings[i][0],buildings[i][2], 0 ));            p.add(new Point(buildings[i][1], buildings[i][2], 1));        }        Collections.sort(p, new PosComparator());        Queue<Integer> pq = new PriorityQueue<Integer>(1, new HeightComparator());        // res only record the turning points        for(Point point : p){            if(point.flag == 0){                if(pq.isEmpty() || (point.h > pq.peek())){                    res.add(new ArrayList<Integer>(Arrays.asList(point.x, point.h)));                }                pq.add(point.h);            } else {                pq.remove(point.h);                if(pq.isEmpty()){                    res.add(new ArrayList<Integer>(Arrays.asList(point.x, 0)));                }                 if(!pq.isEmpty() && point.h > pq.peek()){                    res.add(new ArrayList<Integer>(Arrays.asList(point.x, pq.peek())));                }            }                   }        return fixOutLine(res);    }    }