import java.util.*;public class PacificAtlanticWaterFlow {	class Node{        int x, y;        Node(int x, int y){            this.x = x;            this.y = y;        }    }    public List<int[]> pacificAtlantic(int[][] matrix) {        List<int[]> res = new ArrayList<int[]>();        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {            return res;        }        int row = matrix.length, col = matrix[0].length;        HashSet<Integer> set1 = new HashSet<Integer>();        HashSet<Integer> set2 = new HashSet<Integer>();        int[] dx = {-1, 0, 0, 1};        int[] dy = {0, 1, -1, 0};        // first bfs        Queue<Node> queue1 = new LinkedList<Node>();        // add left and top border        for(int i = 0; i < row; i++){            queue1.offer(new Node(i, 0));            set1.add(i * col);        }        for(int i = 0; i < col; i++){            queue1.offer(new Node(0, i));            set1.add(i);        }        while(!queue1.isEmpty()){            Node cur = queue1.poll();            for(int i = 0; i < 4; i++){                int nx = cur.x + dx[i];                int ny = cur.y + dy[i];                if(nx < 0 || nx >= row || ny < 0 || ny >= col || set1.contains(nx * col + ny) || matrix[nx][ny] < matrix[cur.x][cur.y]){                    continue;                }                queue1.offer(new Node(nx, ny));                set1.add(nx * col + ny);            }        }        // second bfs        Queue<Node> queue2 = new LinkedList<Node>();        // add btm and right border        for(int i = row - 1; i >= 0; i--){            queue2.offer(new Node(i, col - 1));            set2.add(i * col + col - 1);        }        for(int i = col - 1; i >= 0; i--){            queue2.offer(new Node(row - 1, i));            set2.add((row - 1) * col + i);        }        while(!queue2.isEmpty()){            Node cur = queue2.poll();            for(int i = 0; i < 4; i++){                int nx = cur.x + dx[i];                int ny = cur.y + dy[i];                if(nx < 0 || nx >= row || ny < 0 || ny >= col || set2.contains(nx * col + ny) || matrix[nx][ny] < matrix[cur.x][cur.y]){                    continue;                }                queue2.offer(new Node(nx, ny));                set2.add(nx * col + ny);            }        }                // add to res if exist in both set        for(int i = 0; i < row; i++){            for(int j = 0; j < col; j++){                if(set1.contains(i * col + j) && set2.contains(i * col + j)){                    res.add(new int[]{i, j});                }            }        }        return res;    }}