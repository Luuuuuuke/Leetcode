import java.util.*;public class KnightShortestPath {	public class Point {		      public int x, y;		      public Point() { x = 0; y = 0; }		      public Point(int a, int b) { x = a; y = b; }		  }	/**     * @param grid a chessboard included 0 (false) and 1 (true)     * @param source, destination a point     * @return the shortest path      */    public int shortestPath(boolean[][] grid, Point source, Point destination) {        // start from source do bfs till find dest, return count        // otherwise return -1        if(grid == null || grid.length == 0 || grid[0].length == 0){            return -1;        }        int row = grid.length, col = grid[0].length;        int[] dx = {1, 1, -1, -1, 2, 2, -2, 2};        int[] dy = {2, -2, 2, -2, -1, 1, 1, -1};        Queue<Point> queue = new LinkedList<Point>();        HashSet<Integer> visited = new HashSet<Integer>();        queue.offer(source);        visited.add(source.x * col + source.y);        int count = 0;        while(!queue.isEmpty()){            int size = queue.size();            for(int i = 0; i < size; i ++){                Point cur = queue.poll();                if(cur.x == destination.x && cur.y == destination.y){                    return count;                }                for(int d = 0; d < 8; d++){                    int nx = cur.x + dx[d];                    int ny = cur.y + dy[d];                    if(nx < 0 || nx >= row || ny < 0 || ny >= col || grid[nx][ny] || visited.contains(nx * col + ny)){                        continue;                    }                    queue.offer(new Point(nx, ny));                    visited.add(nx * col + ny);                }            }            count++;        }        return -1;    }}