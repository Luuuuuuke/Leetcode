import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.Queue;public class BuildPostOffice1 {	private class Point{        int x, y;        public Point(int x, int y){            this.x = x;            this.y = y;        }    }    /**     * @param grid a 2D grid     * @return an integer     */    public int shortestDistance(int[][] grid) {        // TLE         // traverse grid, record empty point and house point        // if(grid.length == 0 || grid[0].length == 0){        //     return Integer.MAX_VALUE;        // }        // ArrayList<Point> lands = new ArrayList<Point>();        // ArrayList<Point> houses = new ArrayList<Point>();        // int row = grid.length, col = grid[0].length;        // for(int i = 0; i < row; i++){        //     for(int j = 0; j < col; j++){        //         if(grid[i][j] == 0){        //             lands.add(new Point(i,j));        //         }else{        //             houses.add(new Point(i,j));        //         }        //     }        // }        // // for each empty land, calculate the distance to all houses        // // return the minimum        // int min = Integer.MAX_VALUE;        // for(Point empty : lands){        //     int dis = 0;        //     for(Point house : houses){        //         dis += Math.abs(empty.x - house.x) + Math.abs(empty.y - house.y);        //     }        //     min = Math.min(min, dis);        // }        // return min;                // BFS        // get the center of all the houses        // start from the center, do BFS until find a empty land that has mim distance to all houses        if(grid == null || grid.length == 0 || grid[0].length == 0){            return Integer.MAX_VALUE;        }        ArrayList<Integer> xArray = new ArrayList<Integer>();        ArrayList<Integer> yArray = new ArrayList<Integer>();        ArrayList<Point> houses = new ArrayList<Point>();        Queue<Point> queue = new LinkedList<Point>();        boolean[][] visited = new boolean[grid.length][grid[0].length];        for(int i = 0; i < grid.length; i++){            for(int j = 0; j < grid[0].length; j++){                if(grid[i][j] == 1){                    xArray.add(i);                    yArray.add(j);                    houses.add(new Point(i, j));                }            }        }                int xMedian = getMedian(xArray);        int yMedian = getMedian(yArray);        int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};        int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};        queue.add(new Point(xMedian, yMedian));        visited[xMedian][yMedian] = true;        int min = Integer.MAX_VALUE;        while(!queue.isEmpty()){            int size = queue.size();                        for(int i = 0; i < size; i++){                Point cur = queue.poll();                int x = cur.x, y = cur.y;                if(grid[x][y] == 0){                    int dis = getDis(x, y, houses);                    min = Math.min(min, dis);                }                for(int j = 0; j < 8; j++){                    int nx = x + dx[j];                    int ny = y + dy[j];                    if(nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[0].length && !visited[nx][ny]){                        queue.offer(new Point(nx, ny));                        visited[nx][ny] = true;                    }                }            }            if(min != Integer.MAX_VALUE){                return min;            }        }        return Integer.MAX_VALUE;    }        private int getMedian(ArrayList<Integer> nums){        Collections.sort(nums);        int len = nums.size();        if(len % 2 == 0){            return (nums.get(len / 2) + nums.get(len / 2 - 1)) / 2;        } else {            return nums.get(len / 2);        }    }        private int getDis(int x, int y, ArrayList<Point> houses){        int dis = 0;        for(Point each : houses){            dis += Math.abs(x - each.x) + Math.abs(y - each.y);        }        return dis;    }}