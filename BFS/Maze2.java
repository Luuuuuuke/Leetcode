import java.util.*;public class Maze2 {	public class Node{        int x, y, dis;        Node(int x, int y, int dis){            this.x = x;            this.y = y;            this.dis = dis;        }    }    public int shortestDistance(int[][] maze, int[] start, int[] destination) {        if(maze == null || maze.length == 0 || maze[0].length == 0){            return 0;        }        if(start[0] == destination[0] && start[1] == destination[1]){            return 0;        }        int row = maze.length, col = maze[0].length;        int[] dx = {0, 0, -1, 1};        int[] dy = {-1, 1, 0, 0};        HashMap<Integer, Node> map = new HashMap<Integer, Node>();        Queue<Node> queue = new PriorityQueue<Node>(1, new NodeComparator());        Node begin = new Node(start[0], start[1], 0);        queue.add(begin);        map.put(start[0] * col + start[1], begin);        while(!queue.isEmpty()){            Node nd = queue.poll();            for(int i = 0; i < 4; i++){                int nx = nd.x + dx[i];                int ny = nd.y + dy[i];                if(nx < 0 || nx >= row || ny < 0 || ny >= col || maze[nx][ny] != 0){                    continue;                }                int count = 0;                // go staight till wall                while(nx >= 0 && nx < row && ny >= 0 && ny < col && maze[nx][ny] == 0){                    count++;                    nx += dx[i];                    ny += dy[i];                }                nx -= dx[i];                ny -= dy[i];                if(map.containsKey(nx * col + ny)){                    Node tmp = map.get(nx * col + ny);                    if(tmp.dis > nd.dis + count){                        tmp.dis = nd.dis + count;                    }                    continue;                }                if(nx == destination[0] && ny == destination[1]){                    return nd.dis + count;                }                Node tmp = new Node(nx, ny, nd.dis + count);                map.put(nx * col + ny, tmp);                queue.offer(tmp);            }        }        return -1;    }        private class NodeComparator implements Comparator<Node>{        public int compare(Node n1, Node n2){            return n1.dis - n2.dis;        }    }}