public class TheMaze {	class Node{        int x, y;        Node(int x, int y){            this.x = x;            this.y = y;        }    }    public boolean hasPath(int[][] maze, int[] start, int[] destination) {        if(maze == null || maze.length == 0 || maze[0].length == 0){            return false;        }        if(start[0] == destination[0] && start[1] == destination[1]){            return true;        }        int row = maze.length, col = maze[0].length;        int[] dx = {-1, 1, 0, 0};        int[] dy = {0, 0, -1, 1};        HashSet<Integer> visited = new HashSet<Integer>();         Queue<Node> queue = new LinkedList<Node>();        queue.add(new Node(start[0], start[1]));        visited.add(start[0] * col + start[1]);        while(!queue.isEmpty()){            Node nd = queue.poll();            for(int i = 0; i < 4; i++){                int nx = nd.x + dx[i];                int ny = nd.y + dy[i];                if(nx < 0 || nx >= row || ny < 0 || ny >= col || maze[nx][ny] == 1){                    continue;                }                // go straight till wall                while(nx >= 0 && nx < row && ny >= 0 && ny < col && maze[nx][ny] == 0){                    nx += dx[i];                    ny += dy[i];                }                nx -= dx[i];                ny -= dy[i];                if(visited.contains(nx * col + ny)){                    continue;                }                if(nx == destination[0] && ny == destination[1]){                    return true;                }                visited.add(nx * col + ny);                queue.offer(new Node(nx, ny));            }        }        return false;    }}