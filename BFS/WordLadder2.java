import java.util.ArrayList;import java.util.List;import java.util.Set;import java.util.*;public class WordLadder2 {	public List<List<String>> findLadders(String beginWord, String endWord, Set<String> wordList) {        // create graph, nodes are all the strings, if they have only one char difference connect them        // do bfs start from begin node, till find the end word, record prev strings for each node        // do dfs start from end node, till find begin node        List<List<String>> res = new ArrayList<List<String>>();        if(beginWord == null || endWord == null || endWord.length() != beginWord.length()){            return res;        }        // build prevs through bfs        HashMap<String, ArrayList<String>> prevs = new HashMap<String, ArrayList<String>>();        HashMap<String, Integer> distance = new HashMap<String, Integer>();        wordList.add(endWord);        Queue<String> queue = new LinkedList<String>();        queue.add(beginWord);        distance.put(beginWord, 0);        boolean isFound = false;        while(!queue.isEmpty()){            int size = queue.size();            for(int i = 0; i < size; i++){                String cur = queue.poll();                for(String each : getNeibor(cur, wordList)){                    if(each.equals(endWord)){                        isFound = true;                    }                    if(!prevs.containsKey(each)){                        ArrayList<String> prev = new ArrayList<String>();                        prev.add(cur);                        prevs.put(each, prev);                    } else {                        prevs.get(each).add(cur);                    }                    if(!distance.containsKey(each)){                        queue.offer(each);                        distance.put(each, distance.get(cur) + 1);                    }                }            }            if(isFound){                break;            }        }        if(!isFound) return res;        ArrayList<String> sol = new ArrayList<String>();        sol.add(endWord);        dfs(res, sol, endWord, beginWord, prevs, distance);        return res;    }        private List<String> getNeibor(String s, Set<String> wordList){        List<String> res = new ArrayList<String>();        char[] chs = s.toCharArray();        for(int i = 0; i < chs.length; i++){            char old = chs[i];            for(char k = 'a'; k <= 'z'; k++){                if(k == old) continue;                chs[i] = k;                String tmp = String.valueOf(chs);                if(wordList.contains(tmp)){                    res.add(tmp);                }                chs[i] = old;            }        }        return res;    }            private void dfs(List<List<String>> res, List<String> sol, String cur, String target, HashMap<String, ArrayList<String>> prevs, HashMap<String, Integer> distance){        if(cur.equals(target)){            Collections.reverse(sol);            res.add(new ArrayList<String>(sol));            Collections.reverse(sol);            return;        }        List<String> candidates = prevs.get(cur);        for(String each : candidates){            if(distance.get(cur) - 1 != distance.get(each)) continue;            sol.add(each);            dfs(res, sol, each, target, prevs, distance);            sol.remove(sol.size() - 1);        }    }}